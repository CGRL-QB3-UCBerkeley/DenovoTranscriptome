#!/usr/bin/perl
use warnings;
use strict;
use File::Basename;
use Getopt::Std;
use List::Util qw[min max];
use Cwd 'abs_path';
use File::Temp;
#use Bio::DB::EUtilities;


## Author: Ke Bi (ke@berkeley.edu)
## Computational Genomics Resource Laboratory
## California Institute for Quantitative Biosciences
## University of California, Berkeley
## 238 Koshland Hall
## Berkeley, CA 94720-3102


&main;
exit;

sub main {
  &usage if (@ARGV<1);
  
  my $command = shift(@ARGV);
  my %ANNO = ( annotateU => \&annotateU, annotateN => \&annotateN, annotateE => \&annotateE, patching => \&patching, merge =>\&merge);
  die("Unknown command \"$command\"\n") if (!defined($ANNO{$command}));
  &{$ANNO{$command}};
}


sub usage {
  die(qq/
Usage: annotation <command> [<arguments>]\n

Command: 

annotateU:  de novo annotation using uniProt\/Swiss-Prot (via trinotate) 

annotateN:  de novo annotation using NCBI nr

annotateE:  de novo annotation using Ensembl database


<More options for annotateE>

patching:   merge annotated transcripts from one ensemble reference.
            need to run annotateE first
merge:      merge annotated transcripts from multiple ensemble reference.
            need to run patching first

run order annotateE -> patching -> merge 

<end>

\n/);
}

sub merge {
  
  die(qq/
TransAnnotation merge [options] 

options:
-a     FILE      The primary annotated fasta file (e.g. annotated 
                 using the reference that is most closely related
                 to your focal species).
-b     DIR       Directory with all other annotation files 
                 (e.g. a folder containing: chicken.fasta, 
                 human.fasta, fish.fasta, etc.)
-m     FILE      combined_annotation_cds.bed generated by TransAnnotation patching
                 example:
                 cat sample_Danio_annotation_cds.bed sample_Anolis_annotation_cds.bed
                 sample_Homo_annotation_cds.bed > sample_combined_annotation_cds.bed
-d     CHAR      Output prefix

\n\n/) unless (@ARGV);
  
  my %opts = (a=>undef, b=>undef, d=>undef, m=>undef);
  getopts('a:b:d:m:', \%opts);
  

  my $bed = $opts{m};
  my $dir = dir ($opts{b});
  my @all_data = <$dir*fasta>;
  my $name = $opts{d};
  my $anolis = $opts{a};
  my $out = $anolis . "_pair.fasta";
  system ("cp $anolis $out");
    

  
  foreach my $file (@all_data) {

    my $new = readSeq2($out, $bed);
    my %new = %{$new};


    my $out1 = $file. "_pair.fasta";   
    system ("cp $file $out1");
    my $new1 = readSeq2($out1, $bed);
     
    my %new1 = %{$new1};
    my %new2 = (%new, %new1);
    
    my $out2 = $dir . $name . "_pair_annotation_combined.fasta"; 
    print "\n\n";
    print "now comparing ", basename($out), " with ", basename($out1), "!\n";
    PWblast($out, $out1, $out2,\%new2);
     
    system ("mv $out2 $out");

  }
  my $finalout = $dir . $name . "_final_combined_annotation.fasta";
  system ("mv $out $finalout");
  
}

  
  
  
  
  #############################################################

sub readSeq2 {
  my ($seqfile, $bed) = @_;
  
  my %bed;
  open (BED, "<", $bed);
  while (<BED>) {
    chomp (my @line = split /\s+/, $_);
    chomp (my @a = split /:/, $line[6]);
    $bed{$line[0]}{'seq'} += $a[1]; 
  }
  close BED;
  
  my %seq; my $id;
  open(IN, "<$seqfile");
  while(<IN>) {
    chomp(my $line = $_);
    if ($line =~ m/>(\S+)/) {
      $id = $1;
    }
    else {
      my $line2 = $line ;
      $line2 =~ s/[n|N]//g;
      $seq{$id}{"seq"} .= $line;
      $seq{$id}{"len"} = $bed{$id}{'seq'};
    }
  }
  close(IN);
  return(\%seq);
}



  
  
sub PWblast {
  my ($anolis, $next, $out, $new) = @_;
  my %new = %{$new};
  
  my $blastout = dirname($anolis) . "/". basename($anolis) . "_" . basename($next). '.blast.out';
  my $call1 = system("makeblastdb -in $next -dbtype nucl");
  my $call2 = system("blastn -db $next -query $anolis -evalue 1e-50 -outfmt 6 -out $blastout");
  
  my %r;
  my %o;
  
  my %ab;
  my %newsub;
  my $dd = 1;
  open(IN, "<$blastout");
  while(<IN>) {
    chomp(my @line = split /\s+/,$_);
    $r{$line[1]}++;
    $o{$line[0]}++;

    #$ab{$line[0]}{$dd}{'id'} =  $line[0];
    #$ab{$line[0]}{$dd}{'seq'} =  $new{$line[0]}{'seq'} ;
    #$ab{$line[0]}{$dd}{'len'} =  $new{$line[0]}{'len'} ;
    #$dd++;
    #$ab{$line[0]}{$dd}{'id'} =  $line[1];
    #$ab{$line[0]}{$dd}{'seq'} =  $new{$line[1]}{'seq'} ;
    #$ab{$line[0]}{$dd}{'len'} =  $new{$line[1]}{'len'} ;
    #$dd++;  
  }
  close IN;
  #unlink($blastout);
  system("rm $next.n*");
  
  
  #foreach my $gene (sort {$a cmp $b} keys %ab) {
  #  foreach my $id (sort {$ab{$gene}{$b}{'len'} <=> $ab{$gene}{$a}{'len'}} keys %{$ab{$gene}}) {
  #    my $geneid = $ab{$gene}{$id}{'id'};
  #    $newsub{$geneid}{'seq'} = $ab{$gene}{$id}{'seq'};
  #    $newsub{$geneid}{'len'} = $ab{$gene}{$id}{'len'};
  #    last;
  #  }    
  #}
  
  open (NEW, "<", $next);
  while (<NEW>) {
    chomp (my $line = $_);
    if ($line =~ m/>(\S+)/) {
      my $id = $1;
      unless ($r{$id}) {
	$newsub{$id}{'seq'} =  $new{$id}{'seq'} ;
	$newsub{$id}{'len'} =  $new{$id}{'len'} ;
      }
    }
  }
  close NEW;
  
  open (ORI, "<", $anolis);
  while (<ORI>) {
    chomp(my $line = $_);
    if ($line =~ m/>(\S+)/) {
      my $id = $1; 
      #unless ($o{$id}) {
      $newsub{$id}{'seq'} =  $new{$id}{'seq'} ;
      $newsub{$id}{'len'} =  $new{$id}{'len'} ;
      #}
    }
  }  
  close ORI;
  
  
  open (OUT, ">", $out);
  
  foreach my $gene (sort {$a cmp $b} keys %newsub) {
    print OUT ">", $gene, "\n";
    print OUT $newsub{$gene}{'seq'}, "\n";     
  }
  close OUT;
  
  unlink ($next);
  
}


sub patching {
  
  die(qq/
TransAnnotation patching [options] 

options:
-a    FILE      annotated transcripts
-o    DIR       full path to result folder
-r    FILE      Ensemble reference protein (longest_protein.fasta)
-d    FLOAT     How much overlap is allowed between adjoining 
                assembled contigs mapping to the same target [0.3]
-t    INT       number of threads used in blastx search [10]
-e    FLOAT     maximal evalue for blastx hit [1e-10]
-m    INT       minimal percent mismatches to keep a hit [50] 

\n\n/) unless (@ARGV);
  
  my %opts = (a=>undef, o=>undef,t=>10,e=>1e-10,m=>50,r=>undef, d => 0.3);
  getopts('a:o:t:e:m:r:d:', \%opts);


  my $anno = $opts{a};
  my $ref = $opts{r};
  my $resdir = dir ($opts{o});
  mkdir $resdir unless -e $resdir;
  
  my $threads = $opts{t};
  my $eval = $opts{e};
  my $mis = $opts{m};
  my $maxOverlap =$opts{d};

  my %protein;
  open(IN, "<", $ref);
  my $ids;
  while (<IN>){ 
    chomp ($_);
    if ($_ =~ m/^>(ENS\S+)/){
      $ids = $1;
    }
    else {
      $protein{$ids}{'seq'} .= $_;
    }
  }
  close IN;

  my %seq;
  my $lib = $1 if basename ($anno) =~ /(\S+)\.fasta/;

  open (ANNO, "<", $anno);
  
  while (<ANNO>) {
    chomp (my $line = $_);
    if ($line =~ /^>(.*)/) {
      my $header = $1;
      chomp (my $seq = <ANNO>);
      chomp (my @l = split /\s+/, $header);
      my $contig = $l[0];
      
      my $gene = $1 if $l[2] =~ /RefID:(\S+)/;
     
      my $name = $1 if $l[3] =~ /GeneShortName:(\S+)/;
      my $des = $1 if $l[4] =~ /GeneFullName:(\S+)/;
      my $cdhit = $1 if  $l[6] =~ /CodingExonerateHit:(\S+)/;
      my $translen = $1 if $l[8] =~ /TranscriptLength:(\S+)/;
      my $codinglen = $1 if $l[9] =~ /CodingLength:(\S+)/;
      my $e = $1 if $l[10] =~ /Evalue:(\S+)/;
      my $m = $1 if $l[12] =~ /ID:(\S+)/; 
      
      my $astart;
      my $aend;
      my $rstart;
      my $rend;
      
      if ($l[5] =~ /CodingBlastHit:(\d+)-(\d+)/) {
	$astart = $1;
	$aend = $2;	  
      }
      if ($l[7] =~ /RefHit:(\d+)-(\d+)/) {
	$rstart = $1;
	$rend = $2;
      }
      
      
      push @{$seq{$gene}}, {"contig" => $contig, "name" => $name, "des" => $des, "e" => $e, "m" => $m, "astart" => $astart, "aend" => $aend, "rstart" => $rstart, "rend" => $rend, "cdhit" => $cdhit, "translen" => $translen, "codinglen" => $codinglen, "seq" => $seq} ;
      
    }
  } #while (<ANNO>) { 
  
  my $finalSeq = $resdir . $lib . "_intargetPremasked.fa";
  open(SEQ, ">$finalSeq");
  
  foreach my $gene (sort {$a cmp $b} keys %seq) {

    if (scalar @{$seq{$gene}} == 1) {
      print SEQ ">", $gene, "_1", "\n";
      print SEQ $seq{$gene}[0]{'seq'}, "\n";    
    }
    
    if (scalar @{$seq{$gene}} > 1) {
      
      
      my $capin = $resdir . $lib . "_" . $gene . ".in";
      open (CAP, ">", $capin);
      for (my $i =0 ;$i < scalar @{$seq{$gene}}; $i++) {
	print CAP ">", $seq{$gene}[$i]{"contig"}, "\n";
	print CAP $seq{$gene}[$i]{"seq"}, "\n";
	}
      close CAP;
      system ("cap3 $capin"); 
      my $assembled = $capin . ".cap.contigs";
      my $singlets = $capin . ".cap.singlets";
      
      my $assembly1 = $resdir . $lib . ".in_target";
      open (OUT, ">", $assembly1);
      my $tracker = 1;
      
      if (! -z $singlets) {
	open(SIN, "<$singlets");
	while(<SIN>) {
	  chomp(my $line = $_);
	  if ($line =~ m/^>/) {
	    print OUT ">contig" . $tracker, "\n";
	    $tracker++;
	  }
	  else {
	    print OUT $line, "\n";
	  }
	}
	close SIN;
      }
       
      if (! -z $assembled) {
	open(ASS, "<$assembled");
	while(<ASS>) {
	  chomp(my $line = $_);
	  if ($line =~ m/^>/) {
	    print OUT ">contig" . $tracker, "\n";
	    $tracker++;
	  }
	  else {
	    print OUT $line, "\n";
	  }
	}
	close ASS;
      }
      close OUT;
      system("rm $capin" . "*");	

      my $seqfile =  $resdir . $lib. "seqfile.fasta";
      open (SEQ1, ">", $seqfile);
      print SEQ1 ">", $gene, "\n";
      print SEQ1 $protein{$gene}{'seq'}, "\n";
      close SEQ1;
      system("makeblastdb -in $seqfile -dbtype prot");
      
      my $out1 = $resdir . $lib. "_blastNEW.out1";
      system("blastx -query $assembly1 -db $seqfile -out $out1 -evalue $eval -outfmt 6 -num_threads $threads -max_target_seqs 1");
      my %tmp;
   
      
      open(IN, "<$out1");
      while (<IN>) {
	chomp(my $line = $_);
	my @d = split(/\t/,$line);  
	push(@{$tmp{$d[0]}},\@d) if $d[2] >= $mis;
      }
      close(IN);

      
      my $contigs = readSeq($assembly1);
      my %contigs = %{$contigs};	
      system ("rm $assembly1 $out1");
     
      my %matches;
      foreach my $id (keys %tmp) {	
	my $mArray = removeOverlap1($tmp{$id});
	my @mArray = @{$mArray};
	for (my $i = 0; $i < scalar(@mArray); $i++) {
	  push(@{$matches{$mArray[$i][1]}}, \@{$mArray[$i]});
	}
      }	
      undef %tmp;	
      
      my %keep;
      foreach my $id (keys %matches) {

	my ($mArray, $new, $overlap) = removeOverlap(\@{$matches{$id}}, \%contigs, \%keep, $maxOverlap);   
	
	$matches{$id} = $mArray;
	%keep = (%keep, %{$new});  
	if (@{$overlap}) {
	  my @overlap = @{$overlap};
	  
	  @overlap = sort { $b->[0] <=> $a->[0]} @overlap; 
	  #print @{$overlap[0]}[0], "\t", @{$overlap[0]}[1], "\t", @{$overlap[0]}[2],"\t", @{$overlap[0]}[3],"\n";
	  #print "\n\n\n";
	  #    print @{$overlap[1]}[0], "\t", @{$overlap[1]}[1], "\t", @{$overlap[1]}[2],"\t", @{$overlap[1]}[3],"\n";
	  #print "\n\n\n";
	  
	  my $id = @{$overlap[0]}[3];
	  my $start;
	  my $end;
	  
	  if (@{$overlap[0]}[2] > @{$overlap[0]}[1]) {
	    $start = @{$overlap[0]}[1];
	    $end = @{$overlap[0]}[2];
	    
	  } 
	  else {
	    $start =  @{$overlap[0]}[2];
	    $end = @{$overlap[0]}[1];
	    
	  } 
	  
	  my $seq = $contigs{$id};
	  $seq = substr ($seq, $start-1 , $end-$start+1);
	  $contigs{$id} = $seq;
	}
      }

      my $seq = readSeq($seqfile); 
      my %seq = %{$seq};

      system("rm $seqfile" . "*");
      
      my %print;	
  
      foreach my $id (sort {$a cmp $b} keys %seq) {
	
	if ($matches{$id}) {
	  my %length;
	  for (my $i = 0; $i < scalar(@{$matches{$id}}); $i++) {
	    
	    #next if $keep{$matches{$id}[$i][0]}; 
	    my $start = $matches{$id}[$i][8];
	    my $end = $matches{$id}[$i][9];
	    for (my $n = min($start,$end); $n <= max($start,$end); $n++) {
	      $length{$n}++;
	    }			
	    $print{$matches{$id}[$i][0]}{$id}++;
	  }
	  my $overlap = sprintf("%.3f",scalar(keys %length) / length($seq{$id}));	
	  #print ERR $id, "\t", $overlap, "\n";	
	}
	else {
	  #print ERR $id, "\t", "NA\n";
	}
      }
      
      
      my %ids;	
      foreach my $c (sort {$a cmp $b} keys %print) {
	my $newid = join("_", keys %{$print{$c}}) . "_1";
	if ($ids{$newid}) {
	  $ids{$newid}++;	
	  if ($newid =~ m/(\S+)_(\d*)/) {
	    my $core = $1;
	    my $no = $ids{$newid};
	    $newid  = $core . '_' . $no;
	  }
	}
	else {
	  $ids{$newid}++;
	}	
	print SEQ ">", $newid, "\n", $contigs{$c}, "\n"; 
      }
      #close ERR;
        
    } #if (scalar @{$seq{$gene}} > 1)
  }#foreach my $gene (sort {$a cmp $b} keys %seq)
  close SEQ;
  Process ($finalSeq, $resdir, $lib, \%protein, 0 , \%protein, "2", $eval);
    
}

sub Process {  
  my ($final1, $resdir, $name, $trans, $offset, $seqfile, $flag, $eval) = @_;
  
  ## save sequence of references in %ref. and print how many sequences in this file.
  
  my %ref = %{$seqfile};
  my %trans = %{$trans};
  
  ## save sequences in premasked.fasta in %seq 
  my $hash1 = readSeq($final1);
  unlink ($final1);
  my %seq = %{$hash1};

  ## save blastout results in %tmp  

  my %bed;
  my $dd1;

  foreach my $contig (sort {$a cmp $b} keys %seq) {   
    my $yes = 0;
    my $seqid = $1 if $contig =~ m/(\S+)_\d+/;
    my $seq1 =  $seq{$contig}; 

    my $atgc = ($seq1 =~ s/[ATGCYWRMKS]//ig); 
    delete $seq{$contig} if $atgc < 30;
    
    unless ( $flag  eq "4" ) {
      if ($trans{$seqid} && $seq{$contig} ) {
	
	##### if there is a match in the de novo assemblies, print that sequence
	my $final3 = $resdir . $name . "_" . $contig . "_target.fasta";    
	open (TAR, ">", $final3);
	print TAR ">",$contig, "\n";
	
	$dd1++;
	
	my $seq2 =  $seq{$contig};
	$seq2 = removeN ($seq2);
	$seq{$contig} = $seq2;
	
	print TAR $seq{$contig}, "\n";
	#print $seq{$contig}, "\n";
	### print the corresponding protein reference sequence in the target sequence file
	my $ref = $resdir . $name . "_" . $contig . "_ref.fasta";
	open (REF, ">", $ref);
	print REF ">", $seqid, "\n";
	print REF $trans{$seqid}{'seq'},"\n";
	
	close TAR;
	close REF;
	my $protid = $seqid; 
	my ($newbed, $newseq) = annotateContigs ($final3, $ref, $resdir, $name, $contig, \%trans, $protid ,\%seq, $flag);
	unlink ($final3, $ref);
	%seq = %{$newseq};
	%bed = (%bed, %{$newbed});      
      }
    } ## unless ( $flag  eq "4" ) {
 } ## foreach my $contig (sort {$a cmp $b} keys %seq)

  my ($exonflankingbed, $flankingbed ,$seq1, $bed2) = modbed (\%bed, $resdir, $name, $offset, \%seq); 
  my %exonflankingbed = %{$exonflankingbed} ;
  my %flankingbed= %{$flankingbed};
  %seq = %{$seq1};
  %bed = %{$bed2};
  
  #### remove utr from %bed if there is utr present;
  unless ($flag eq "4") {
    foreach my $contig (sort {$a cmp $b} keys %bed) {
      if ($bed{$contig}[0][1] == 0) {
	my $start = $exonflankingbed{$contig}[0][0];
	my $end = $exonflankingbed{$contig}[0][1];
	delete $flankingbed{$contig};
	$flankingbed{$contig}[0][0] = $start;
	$flankingbed{$contig}[0][1] = $end;
	delete $bed{$contig};
      }
    }
  }
 
  my $Ns = 'NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN'; ##40 Ns
  my %position;
  my %everything;

  foreach my $contig (sort {$a cmp $b} keys %ref) {
    my $final3 = $resdir . $name . "_" . $contig . "_target.fasta";    
    my $ref = $resdir . $name . "_" . $contig . "_ref.fasta";        
    open (TAR, ">", $final3);    
    open (REF, ">", $ref);
    print REF ">", $contig, "\n";
    print REF $ref{$contig}{"seq"},"\n";
    
    my $yes = 0;
    my $d;
    foreach my $id (sort {$a cmp $b} keys %seq) { 

      my $seqid = $1 if $id =~ m/(\S+)_\d+/;
      
      if ($contig eq $seqid) { 

	print TAR ">",$id, "\n";
	print TAR $seq{$id}, "\n";
	$yes++;
      }
    }
    close REF;
    close TAR;
    
    unlink ($final3, $ref) if $yes == 0;

   
    if ($yes > 0) { ### if there is a match
      
      my $BEDblastout = $resdir . $name . "_" . $contig .'.blastBED.out';
      my $BEDblastout1 = $resdir . $name . "_" . $contig .'.blastBED.out.sorted';
      
      my $call5 = system("makeblastdb -in $final3 -dbtype nucl > log");
      my $call6 = system("tblastn -db $final3 -query $ref -evalue $eval -outfmt 6 -out $BEDblastout ");
      #print "tblastn -db $final3 -query $ref -evalue $eval -outfmt 6 -out $BEDblastout ", "\n";
      system("rm $final3.n*  log");
      system ("sort -k 1,1 -k 7n,12 $BEDblastout > $BEDblastout1");
   
      open (IN, "<", $BEDblastout1);
      unlink ($final3, $ref);
      unlink ($BEDblastout, $BEDblastout1);
      
      my $count =0;
      while (<IN>) {
       $count++;		
      }	
      seek IN, 0, 0;
      
     if ($count == 0) {
	foreach my $id (sort {$a cmp $b} keys %seq) { 
	  my $seqid = $1 if $id =~ m/(\S+)_\d+/;
	  if ($contig eq $seqid) { 
	    delete $seq{$id};	    
	  }
	}
      } ## if ($count == 0) {
      print $contig, " has no blast match???!!!! OK, $contig is removed from the marker list. " , "\n" if $count == 0;

      if ($count > 0) {
	
        my $ds = 0;
	my $addlength;
	my $previous = 0;
	my @match;
	
	while (<IN>) {
	  my @a = split /\s+/,$_;
	  my $refContig = $a[0];
	  my $assContig = $a[1];
	  
  	  my $answer = match ($assContig,\@match);
	  
	  push @match, $assContig unless ($answer eq 'yes') ;
	  $everything{$refContig}{'seq'} .=  $seq{$assContig} . $Ns unless ($answer eq 'yes' ); ## when $assContig is a new contig in the array
	  
          $previous = length ($seq{$assContig} . $Ns) unless ($answer eq 'yes'); ## when $assContig is a new contig in the array	  
          
	  # print $assContig , "\t", $previous, "\n" unless ($answer eq 'yes');
	  
	  $addlength = length ($everything{$refContig}{'seq'}) - $previous unless ($answer eq 'yes'); ## when $assContig is a new contig in the array
          
	  
	  unless ($answer eq 'yes') {
            if ($bed{$assContig}){
	      for (my $i = 0; $i < scalar @{$bed{$assContig}}; $i++) {
		#print $assContig, "\t", $bed{$assContig}[$i][0], "\t", $bed{$assContig}[$i][1], "\n";
		$bed{$assContig}[$i][0] = $bed{$assContig}[$i][0] + $addlength  ;
		$bed{$assContig}[$i][1] = $bed{$assContig}[$i][1] + $addlength ;
		#print $assContig, "\t", $bed{$assContig}[$i][0], "\t", $bed{$assContig}[$i][1], "\n";
	      }
	    }   
	    $ds++;
	  }
	  
	} ## while (<IN>)
	
	close IN;	
	$everything{$contig}{'seq'} = substr($everything{$contig}{'seq'}, 0, length($everything{$contig}{'seq'})-length ($Ns));
	
      } ## if ($count > 0) {
    } ##if ($yes > 0)
  } ##foreach my $contig (sort {$a cmp $b} keys %ref) {	
  
  
  
  ###print all different output files. 
  my $exonbed;
  $exonbed  = $resdir . $name ."_annotation_cds.bed";
  open (EXON, ">", $exonbed);
  
  foreach my $contig (sort {$a cmp $b} keys %bed) {
    for (my $i = 0; $i < scalar @{$bed{$contig}}; $i++) {
      my $seqig = $1 if $contig =~ /(\S+)_\d+/;

      my $e_value = "only_exonerate_hit";
      my $bit_score = "only_exonerate_hit";
      my $sim = "only_exonerate_hit";
      
      if ($everything{$seqig}) {
	my $target = $resdir . $name . "_" . $contig . "_bed_target.fasta";
	my $ref = $resdir . $name . "_" . $contig . "_ref.fasta";
	open (TAR, ">", $target);
	open (REF, ">", $ref);
	
	print REF ">", $seqig, "\n";
	print REF $ref{$seqig}{"seq"},"\n";
	close REF;
	
	print TAR ">", $contig, "\n";
	print TAR substr ($everything{$seqig}{'seq'}, $bed{$contig}[$i][0], $bed{$contig}[$i][1] - $bed{$contig}[$i][0]), "\n";
	
	close TAR;
	
	my $BED = $resdir . $name . "_" . $contig .'_bed_target_blastBED.out';
	
	system("makeblastdb -in $target -dbtype nucl > log");
	system("tblastn -db $target -query $ref -evalue $eval -outfmt 6 -out $BED ");
	
	system("rm $target.n*  log");
	unlink ($target,$ref);
	
	open (IN, "<", $BED);
	unlink ($BED);
	
	while (<IN>) {
	  chomp (my @line = split /\s+/, $_);
	  $sim = $line[2];
	  $e_value = $line[10];
	  $bit_score = $line[11];
	}
	close IN;
      }

      my $length1 =  $bed{$contig}[$i][1] - $bed{$contig}[$i][0]; 
      print EXON  $name, "_", $seqig, "\t", $bed{$contig}[$i][0], "\t", $bed{$contig}[$i][1], "\t", "Evalue:$e_value", "\t", "BitScore:$bit_score","\t", "Similarity:$sim","\t", "CodingLength:$length1", "\n" if $seq{$contig};
      
    }
  }
  
  close EXON;
  
  
  my $finalfasta  =  $resdir . $name .'_annotation.fasta';
  open (FASTA, ">", $finalfasta);
  
  #$everything{$contig}{'seq'}
  foreach my $item (sort {$a cmp $b} keys %everything) {   
    print FASTA ">", $name, "_", $item, "\n";
    print FASTA $everything{$item}{'seq'}, "\n";     
  }
  close FASTA ;
  
}



#curse the recursive function!
sub removeOverlap1 {
  my ($array) = @_;  
  for (my $i = 0; $i < scalar(@$array); $i++) {
    my $start1 = $array->[$i]->[6];
    my $end1 = $array->[$i]->[7];
    my %bp;
    for (my $n = min($start1,$end1); $n <= max($start1,$end1); $n++) {
      $bp{$n}++;
    }
    for (my $j = $i+1; $j < scalar(@$array); $j++) { 	
      my $start2 = $array->[$j]->[6];
      my $end2 = $array->[$j]->[7];
      my $overlap = 0;
      for (my $n = min($start2,$end2); $n <= max($start2,$end2); $n++) {
	$overlap++ if $bp{$n};
      }
      $overlap = $overlap / min(abs($start1 - $end1),abs($start2 - $end2));	
      if ($overlap > 0.2) {
#	print "yes\n";
 #       undef @{$array}; 	
      } ##if ($overlap > 0.2) {
    }##for (my $j = $i+1; $j < scalar(@$array); $j++) { 	
  } ##for (my $i = 0; $i < scalar(@$array); $i++) {	
  return($array);	
}

sub readFile {
  my ($file,$hash,$base) = @_;
  if (-f $file) {
    open(IN, "<$file");	
    my $id; my $tracker = 1;
    while(<IN>) {
      chomp(my $line = $_);
      if ($line =~ m/>(\S+)/) {
	$id = $base . $tracker;
	$tracker++;
      }
      else {
	$hash->{$id} .= $line;
      }
    }
    close(IN);	
  }	
  return($hash);
}	

sub readSeq {
  my ($seqfile) = @_;
  my %seq; my $id;
  open(IN, "<$seqfile");
  while(<IN>) {
    chomp(my $line = $_);
    if ($line =~ m/>(\S+)/) {
      $id = $1;
    }
    else {
      $seq{$id} .= $line;
    }
  }
  close(IN);
  return(\%seq);
}

sub seqhash {
  my ($file) = @_;
  my %seq;
  open (IN, "<", $file); 
  my $id;
  my $d = 0;
  while (<IN>) {
    chomp (my $line = $_);
    if ($line =~ m /^>(Contig\d+_\d+)$/) {   
      $id = $1;
      chomp (my $seq = <IN>);
      $seq{$id}{'seq'} = $seq;
    }
    if ($line =~ m /^>Contig\d+_Contig\d+/) {
      print $line, "\n";
      $d++;    
    }  
    else {
    next;
    }
  }
  print "\n\nIn ", $file, ", " ,  $d, " chimeric sequences are discarded!", "\n\n";
  close IN;
  return (\%seq);
}


sub MakeBed {
  my ($bed, $offset) = @_;
  open (BED, "<", $bed);
  my @Bed;
  my $count =0;
  while (<BED>) {
    chomp (my @name = split /\s+/, $_);
    #add bed to matrix
    
      $Bed[$count] -> [0] = $name[0]; #contig name
      $Bed[$count] -> [1] = $name[1]; #start coordinate
      $Bed[$count] -> [2] = $name[2]; #end coordinate
      $count++;
    
  }
  close BED;
  
  @Bed = sort { $a->[0] cmp $b->[0] || $a->[1] <=> $b->[1] || $a->[2] <=> $b->[2]} @Bed; 

  
  my ($tmp_offset, $tmp);

  #create temp files to save space!  
  $tmp_offset = File::Temp->new(SUFFIX=>'.offset');
  $tmp = File::Temp->new(SUFFIX=>'.original');

  foreach (@Bed) {
    print $tmp @{$_}[0], "\t", @{$_}[1], "\t", @{$_}[2], "\n";   
    if (@{$_}[1] >= $offset) {
      print $tmp_offset @{$_}[0], "\t", @{$_}[1]-$offset, "\t", @{$_}[2]+$offset, "\n";
    }
    else {
      print $tmp_offset @{$_}[0], "\t", 0, "\t",  @{$_}[2]+$offset, "\n";
    }
  }
  
  seek $tmp, 0, 0; #rewind $region list to beginning for main loop
  seek $tmp_offset, 0, 0;
  
  my $out1 = $bed . "_offset_final";
  mining ($tmp_offset, $out1);
  my $out2 = $bed . "_final";
  mining ($tmp, $out2);
  unlink ($tmp_offset, $tmp);
  system ("mv $out2 $bed");
  system ("rm $out1");
}

sub mining {
  my ($file, $out) = @_;
  open (IN, "<", $file);
  
  my $howmany = 0;
  while (<IN>) {
     $howmany++;
    }
    close IN;

    if ($howmany > 1) {
    open (IN, "<", $file);
    open (OUT, ">", $out);
    chomp (my $first = <IN>);
    my @d = split /\s+/, $first;
    
    my $gene = $d[0];
    my $start = $d[1];
    my $end = $d[2];
    
    while (<IN>) { ##do not forget to process the end of file!!
      
      chomp (my @line = split /\s+/, $_);
      if ($line[0] eq $gene) {
	
	if (!eof){ ## if not the end of the file
	  
	  if ($line[1] > $end) {
	    print OUT $gene, "\t", $start, "\t", $end, "\n";
	    $start = $line[1];
	    $end = $line[2];
	  } 	
	  if ($line[1] <= $end && $line[1] >= $start) {
	    if ($line[2] >= $end) {
	      $end = $line[2];	  
	    }	 	  
	  }
	  if ($line[1] < $start) {
	    $start = $line[1];
	    if ($line[2] >= $end) {
	      $end = $line[2];	  
	    }	  
	  }
	} ##if (!eof){
	
	else { #end of the file; need to print both lines. Same as below
	  if ($line[1] > $end) {
	    print OUT $gene, "\t", $start, "\t", $end, "\n";
	    print OUT $gene, "\t", $line[1], "\t", $line[2], "\n";
	  } 	
	  if ($line[1] <= $end && $line[1] >= $start) {
	    if ($line[2] >= $end) {
	      print OUT $gene, "\t", $start, "\t", $line[2], "\n";	      
	    } 
	    else {
	      print OUT $gene, "\t", $start, "\t", $end, "\n";
	    }
	  }
	  if ($line[1] < $start) {
	    if ($line[2] >= $end) {
	      print OUT $gene, "\t", $line[1], "\t", $line[2], "\n";
	    }
	    else {
	      print OUT $gene, "\t", $line[1], "\t", $end, "\n";
	    } 
	  }
	} ## else	
      } ##if ($line[0] eq $gene) {
      
      
      if ($line[0] ne $gene) {
	if (!eof) {
	  print OUT $gene, "\t", $start, "\t", $end, "\n";	
	  $gene = $line[0];
	  $start = $line[1];
	  $end = $line[2];   
	}
	else {
	  print OUT $gene, "\t", $start, "\t", $end, "\n";
	  $gene = $line[0];
	  $start = $line[1];
	  $end = $line[2]; 
	  print OUT $gene, "\t", $start, "\t", $end, "\n";
	}
      
       } ##if ($line[0] ne $gene) {
    } ## while (<IN>) {
    close IN;
    close OUT;

    } ## if $howmany >1
  elsif ($howmany  == 1)  {
    open (IN, "<", $file);
    open (OUT, ">", $out);
    chomp (my $first = <IN>);
    my @d = split /\s+/, $first;
    
    my $gene = $d[0];
    my $start = $d[1];
    my $end = $d[2];
    
    print OUT $gene, "\t", $start, "\t", $end ,"\n";
    close IN;
    close OUT;
    
  } ##elsif
  
  else {
    print $file, "\n";
    exit;    
  }
} 

    
sub modbed {
  my ($bed, $resdir, $name, $offset, $seq) = @_;

  my %newbed = %{$bed};
  my %seq = %{$seq};
  my %exonflankingbed;
  my %flankingbed;


  my $rebed = $resdir . $name . "_bed.txt";
  open (BED, ">", $rebed); 
    
  foreach my $contig (sort {$a cmp $b} keys %newbed) { 
    for (my $i = 0; $i < scalar (@{$newbed{$contig}}); $i++) {
      print BED $contig, "\t", $newbed{$contig}[$i][0], "\t", $newbed{$contig}[$i][1], "\n"      
    }
  }
  close BED;
  MakeBed ($rebed, 0);

  my %bed;
  
  open (BED, "<", $rebed);
  while (<BED>) {
    chomp (my @l = split /\s+/,$_);
    push @{$bed{$l[0]}},  [ $l[1],$l[2]];

  }
  close BED;
  unlink ($rebed);
   
  foreach my $contig (sort {$a cmp $b} keys %bed) { 
    my $tmpallbed = $resdir . $name . "_" . $contig . "_all_tmp.bed";
    my $tmpflankingbed = $resdir . $name . "_" . $contig . "_flanking_tmp.bed";
    
    open (BEDALL, ">",$tmpallbed);
    open (BEDF, ">", $tmpflankingbed);
    
    my $contiglength = length ($seq{$contig});
    
    for (my $i = 0; $i < scalar (@{$bed{$contig}}); $i++) {
      
      my $start;
      my $end;
      my $nextS;
      my $formerE;
      
      $start = $bed{$contig}[$i][0];
      $end = $bed{$contig}[$i][1];
 
      $nextS = $bed{$contig}[$i+1][0] if ($i < scalar (@{$bed{$contig}}) -1);
      $nextS = $contiglength if ($i == scalar (@{$bed{$contig}}) -1);
      $formerE = 0 if ($i == 0);
      $formerE = $bed{$contig}[$i-1][1] if  ($i > 0);
      
      my $news = $start - $offset;
      $news = $formerE if $news < $formerE;
      
      my $newe = $end + $offset;
      $newe = $nextS if $newe > $nextS;	  
       print "BED:", $contig, "\t", $start, "\t", $end, "\n" if ($newe < $news);
       #print "ALLBED:",  $contig, "\t", $news, "\t", $newe, "\n" if ($newe < $news);
       print $contig, "\t", " is inverted bed file and removed!", "\n" if ($newe < $news);
       #last if ($newe < $news);
       delete $seq{$contig} if ($newe < $news);
    
       

       print BEDALL $contig, "\t", $news, "\t", $newe, "\n" if ($bed{$contig}[$i][1] != 0 && $newe > $news );
        
       
       #exit if ($newe < $news);
      unless ($bed{$contig}[$i][1] == 0) {
	my $newf1s = 0;
	my $newf1e = 0;
	my $newf2s = 0;
	my $newf2e = 0;
	
	if ($news < $start) {
	  $newf1s = $news;
	  $newf1e = $start;	    
	}
	if ($newe > $end) {
	  $newf2s = $end;
	  $newf2e = $newe;	    
	}
	print BEDF  $contig, "\t", $newf1s, "\t", $newf1e, "\n" if (($newf1e - $newf1s) > 20 && $newe > $news) ;
	#print $contig, "\t", $newf1s, "\t", $newf1e, "\n" if (($newf1e - $newf1s) > 20) ;
	print BEDF  $contig, "\t", $newf2s, "\t", $newf2e , "\n" if (($newf2e - $newf2s) > 20 && $newe > $news);
	#print  $contig, "\t", $newf2s, "\t", $newf2e , "\n" if (($newf2e - $newf2s) > 20);
      }
    } ## or (my $i = 0; $i < scalar (@{$bed{$contig}}); $i++) {	
    close BEDALL;
    close BEDF;
    
    #my $tmpallbed1 = $tmpallbed . ".1";
    #system ("cp $tmpallbed $tmpallbed1");
    
    MakeBed ($tmpallbed, 0) unless -z $tmpallbed;
    MakeBed ($tmpflankingbed, 0) unless -z $tmpflankingbed;
    
    unless (-z $tmpallbed ) {
    open (NEWBEDALL, "<", $tmpallbed);
    while (<NEWBEDALL>) {
      chomp (my @l = split /\s+/, $_);
      push @{$exonflankingbed{$l[0]}}, [$l[1] , $l[2]] if ($l[2] - $l[1] > 20 );
    }
    close NEWBEDALL;
  }
    unless (-z $tmpflankingbed ) {
      open (NEWBEDFL, "<", $tmpflankingbed);
      while (<NEWBEDFL>) {
	chomp (my @l = split /\s+/, $_);
	push @{$flankingbed{$l[0]}}, [$l[1], $l[2]] if ($l[2] - $l[1] > 20 );
      }
      close NEWBEDFL;
    }
    unlink ($tmpallbed, $tmpflankingbed);
    
  } #foreach my $contig (sort {$a cmp $b} keys %bed)
  return (\%exonflankingbed, \%flankingbed, \%seq, \%bed);  
}

sub removeN {  
  my ($line) = @_;
  if ($line =~ /^[n|N]*[A|C|G|T|Y|S|K|R|W|M]+/ || $line =~ /[A|C|G|T|Y|S|K|R|W|M]+[n|N]*$/) {
    $line =~ s/^[n|N]*//g if $line =~ /^[n|N]*/;
    $line = reverse $line;
    $line =~ s/^[n|N]*//g if $line =~ /^[n|N]*/;
    $line = reverse $line;
  }
  return $line;
  
}  

sub match {
  my ($item, $array) = @_;
  my $answer = 'no';

  my @array = @{$array};

  foreach (@array) {
    my $line = $_;
    $answer = 'yes' if $line eq $item;
  }
  return ($answer);
}

  sub annotateContigs {
  my ($contig, $refprot, $resdir, $lib, $contigid, $trans, $gene, $seq, $flag) = @_;
  #  $final3, $ref, $resdir, $name, $contig, \%trans, $trans{$seqid}{'protid'},\%seq
  my %bed;
  my %trans = %{$trans};
  my %seq = %{$seq};
 
  my @call = `exonerate -m protein2genome -t $contig -q $refprot --showtargetgff TRUE --showalignment NO --showvulgar 0 -n 1 | grep 'cds' | sort -k 4,4 -n`;
  
  if (@call) {	 
	
    my (@gs, @ge);
    my $reverse = 0;
    my $forward = 0;
    foreach my $line (@call) { 
      my @d = split(/\s+/,$line);
      my ($gs,$ge);
  
      if ($d[6] =~ m/-/) {
 
	my $length = length($seq{$contigid});
	$gs = $length - $d[4] + 1;
	$ge = $length - $d[3] + 1;

	push(@gs,$gs); push(@ge,$ge);
	$reverse ++;												
      }
      else {
	$gs = $d[3]; $ge = $d[4];
	push(@gs,$gs); push(@ge,$ge);
	$forward ++;
      }
    } ##foreach my $line (@call)	
    
    if ($reverse && ! $forward) {
      my $seqq = $seq{$contigid};
      $seqq = reverse($seqq);
      $seqq =~ tr/atgcATGC/tacgTACG/;
      $seq{$contigid} = $seqq; 
      @gs = reverse(@gs);
      @ge = reverse(@ge);
    } ##if ($reverse && !$foward)

    if ($reverse && $forward) {
      delete $seq{$contigid};
      print "$contigid is chimeric!!!\n";
    }
    
    unless ($reverse && $forward) {	
      for (my $x = 0; $x < scalar(@gs); $x++) { 	
	push @{$bed{$contigid}},  [$gs[$x]-1 ,$ge[$x]];	
      }
    }    
  } ##if (@call)

  
  #a blast match but no exonerate match, check if it is that because it is a UTR ?	
  else {
    if ($flag eq "1" ||  $flag eq "2") {
      delete $seq{$contigid};
      print "$contigid has no annotations!!!\n";
    }

    if ($flag eq "3") {
    my $seqid = $1 if $contigid =~ m/(\S+)_\d+/;

    my $seqTrans =  $resdir. $lib . "_" . $contigid .   "_trans.fa";
    open (COUT, ">", $seqTrans);
    print COUT ">", $trans{$seqid}{'protid'}, "\n", $trans{$seqid}{'transeq'} , "\n";
    close COUT;
        
    my $call = system("blat $seqTrans $contig blatTmp -out=blast8");
   
    open(IN, "<blatTmp");
    chomp(my $match = <IN>) unless (-z "blatTmp"); ###only take the first match
    
    if ($match) {
      my @d = split(/\s+/,$match);
      if ($d[10] <= 1e-5) {

	my $max;
	my $min;
	my $start;
	my $end;
	if ($d[8] < $d[9]) {
	  $max = $d[9];
	  $min = $d[8];
	  $start = $d[6];
	  $end = $d[7];
	} ##if ($d[8] < $d[9])
	else {
	  my $seqq = $seq{$contigid};
	  $seqq = reverse($seqq);
	  $seqq =~ tr/atgcATGC/tacgTACG/;
	  $seq{$contigid} = $seqq;  
	  $max = $d[8];
	  $min = $d[9];
	  my $len = length ($seqq);
	  
	  $end = $len - $d[6] + 1;
	  $start = $len - $d[7] + 1;
	} ##else

	
	my $overlap = 0;
	for (my $i = $min; $i <= $max; $i++) {
	  if ($i > $trans{$seqid}{'u5'} && $i < $trans{$seqid}{'u3'}) {
	    $overlap++;
	  }
	}	

	if ( ($overlap / ($max - $min) ) < 0.2 ) {
	  push @{$bed{$contigid}},  [0, 0] ;
	  push @{$bed{$contigid}},  [$start-1, $end] ;

	}
        else {
	delete $seq{$contigid} ;
	print "$contigid has no annotations!!!\n";
      } ##else
       
      
      }	## if ($d[10] <= 1e-5) {

      else {
	delete $seq{$contigid} ;
	print "$contigid has no annotations!!!\n";
      } ##else

    
    } ##if $match
    
    else {
      delete $seq{$contigid};
      print "$contigid has no annotations!!!\n";

    }
    
    system("rm blatTmp");
    unlink($seqTrans);
   } ## if ($flag eq "3") {
  } ###else 

  return(\%bed, \%seq);
}




sub annotateN {

  die(qq/
TransAnnotation annotateE [options] 

options:
-a    FILE      assembled fasta file by trinity
-o    DIR       full path to result folder (should be named including sampleName)
-t    INT       number of threads used in blastx search [10]
-e    FLOAT     maximal evalue for blastx hit [1e-10]
-m    INT       minimal percent mismatches to keep a hit [50] 
-r    FILE      nr reference  (must be pre-formatted!!)
-g    FILE      gilist to blast


!!Dependencies!!: 
NCBI BLAST+
Bioperl
Bio::DB::EUtilities

\n\n/) unless (@ARGV);
  
  my %opts = (a=>undef, o=>undef,t=>10,e=>1e-10,m=>50,r=>undef,g=>undef);
  getopts('a:o:t:e:m:r:g:', \%opts);


#7742 vertebrates
#9347 mammals
#1294634 reptilia

  my $dir = dir($opts{o});
  mkdir $dir unless -e $dir;
  
  my $ass = $opts{a};
  my $np = $opts{t};
  my $evalue = $opts{e};
  my $assUnique = uniqueass ($ass) unless (-f $ass. ".unique");
  $assUnique = $ass . ".unique";

  ##define variables for filter
  my $mismat = $opts{m};
  my $ginum; 
  $ginum = $opts{g};
 
  my $P = $opts{r};

  
  my $outfile1;
  if (-f $dir . basename ($assUnique) . '.blast.out') {
    $outfile1 = $dir . basename ($assUnique) . '.blast.out'; 
  }
  unless (-f $dir . basename ($assUnique) . '.blast.out') {
    $outfile1 = blastProteins($assUnique, $P, $np, $evalue, $dir, $ginum); 
  }

  my $seqref = readfasta ($assUnique);

  annotateNcore ($outfile1,$evalue, $mismat, $seqref, $dir, $P);
}

sub getname {
  my ($gi) = @_;
  my @ids;
  push @ids,$gi;
  my $final;
  my $factory = Bio::DB::EUtilities->new(-eutil => 'esummary',
					 -email => 'mymail@foo.bar',
					 -db    => 'protein',
					 -id    => \@ids);
  while (my $ds = $factory->next_DocSum) {
    #print "ID: ",$ds->get_id,"\n";
    # flattened mode
    while (my $item = $ds->next_Item('flattened'))  {
      if ( $item->get_name eq "Title" ) {
        # not all Items have content, so need to check...
        $final =  sprintf ("%s",$item->get_content) if ($item->get_content);
	$final = "NA" if (!$item->get_content);
      }
    }
    
  }
  return ($final);

}

sub annotateNcore {
  my ($blast, $evalue, $mismat, $seqref, $dir, $ref) = @_;
  
  my %anno;
  my %seq = %{$seqref};

   my %protein;

  open (BLAST, "<", $blast);
  while (<BLAST>) {
    chomp (my @a = split /\s+/, $_);
    my $contigID = $a[0];
    my $gene;
    my $comp;
    if ($contigID =~ m /c(\S+)_g(\d+)_i\d+/) {
      $gene = $1;
      $comp = $2;
    }
    
    my $ms = $a[2];
    next if $ms <= $mismat;
    next if $a[10] >= $evalue;
    
    if (!$anno{$gene}{$comp}) { 
      
      $anno{$gene}{$comp}{"mismatch"} = $a[2];
      $anno{$gene}{$comp}{"query_start"} = $a[6];
      $anno{$gene}{$comp}{"query_end"} = $a[7];
      $anno{$gene}{$comp}{"hit_start"} = $a[8];
      $anno{$gene}{$comp}{"hit_end"} = $a[9];
      $anno{$gene}{$comp}{"evalue"} = $a[10];
      $anno{$gene}{$comp}{"bit"} = $a[11];
      $anno{$gene}{$comp}{"seq"} = $seq{$contigID}{"seq"};
      $anno{$gene}{$comp}{"length"} = $seq{$contigID}{"length"};
      
      $anno{$gene}{$comp}{"ncbiID"} = $a[1];
       
      
      my $gis;
      if ($anno{$gene}{$comp}{"ncbiID"} =~ m/^gi\|(\d+)\|/) {
	$gis = $1;
	$anno{$gene}{$comp}{'refgenefull'} = $gis;
      }
      else {
	print "cant not find gi number for $a[1]!\n";
	exit;
      }
      
      my $namefull = getname ($gis);

      $anno{$gene}{$comp}{"nameFull"} = uc ($namefull);
      
      my $fileout = $dir . "tmp.txt";
      system ("blastdbcmd -db $ref  -entry $gis > $fileout");
      open (FILE, "<", $fileout);
      while (<FILE>) {
	chomp (my $line = $_); {
	  if ($line !~ m/^>/) {
	    $protein{$gis}{'seq'} .= $line;
	    $protein{$gis}{'length'} += length ($line);
	    
	  }
	}
      }
      close FILE;
      unlink ($fileout);
      
    } 
  }
  close BLAST;

  my %ah;
  foreach my $gene (sort {$a <=> $b} keys %anno) {
    foreach my $comp (sort {$a <=> $b}  keys %{$anno{$gene}} ) {
      
      if ($anno{$gene}{$comp}{'nameFull'} =~ m/, PARTIAL/) {
	if ($anno{$gene}{$comp}{'nameFull'} =~ m/([\S+\s+^, PARTIAL]+), PARTIAL/) {
	  push @{$ah{$gene}{'comp'}}, $1;
	  $anno{$gene}{$comp}{'name2nd'} =  $1;   
	}
	else {
	  die ("$anno{$gene}{$comp}{'nameFull'} contains PARTAIL but doesn't match expected string!?\n");
	}
      }
      else {
	if ($anno{$gene}{$comp}{'nameFull'} =~ m/([\S+\s+^\[]+)\[/) {	
	  push @{$ah{$gene}{'comp'}}, $1;
	  $anno{$gene}{$comp}{'name2nd'} =  $1; 
	  
	}
	else {
	  push @{$ah{$gene}{'comp'}}, uc ($anno{$gene}{$comp}{'nameFull'});
	  $anno{$gene}{$comp}{'name2nd'} = $anno{$gene}{$comp}{'nameFull'};
	}
      }

      
      
      push @{$ah{$gene}{'gene'}}, $comp;
      
      if ($anno{$gene}{$comp}{'query_start'} >  $anno{$gene}{$comp}{'query_end'}) {
	$anno{$gene}{$comp}{'seq'} = reverse($anno{$gene}{$comp}{'seq'});
	$anno{$gene}{$comp}{'seq'} =~ tr/ATGC/TACG/;
	
	my $newstart = $anno{$gene}{$comp}{'length'} - $anno{$gene}{$comp}{'query_start'} + 1;
	my $newend = $anno{$gene}{$comp}{'length'} - $anno{$gene}{$comp}{'query_end'} + 1;
	
	$anno{$gene}{$comp}{'query_start'} = $newstart ;
	$anno{$gene}{$comp}{'query_end'} = $newend;
	
      }
    }  
  }

  
  my $newanno = exonerate ($dir, \%anno, \%protein);
  %anno = %{$newanno};



  foreach my $gene (sort {$a <=> $b} keys %anno) {
    
    if (scalar @{$ah{$gene}{'comp'}} == 1 ) {
      foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
	$anno{$gene}{$comp}{'complete'} = "all";
      }
    } #if (scalar @{$ah{$gene}{'comp'}} == 1 ) {
    
      if (scalar @{$ah{$gene}{'comp'}} > 1 ) {

	my %seen = ();
	foreach my $item (@{$ah{$gene}{'comp'}}) {
	  $seen{$item}++ ;
	}
	my @not_unique = grep { $seen{$_} > 1 } keys %seen ;

	#foreach (@not_unique) {
	#  print $_, "\n";
	#}
	#foreach (@{$ah{$gene}{'comp'}}) {
	#  print $_, "\n";
	#}

	
	my $d = 1;
	foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
	  
	  if (grep {$_ eq $anno{$gene}{$comp}{'name2nd'} } @not_unique) {
	    $anno{$gene}{$comp}{'complete'} = "part$d";
	    $d++;
	  }
	  else {
	    $anno{$gene}{$comp}{'complete'} = "all";
	  }
	} #foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_end'}} keys %{$anno{$gene}}) {
      } #if (scalar @{$ah{$gene}{'comp'}} > 1 ) {
  }#foreach my $gene (sort {$a cmp $b} keys %anno) {

  my $final =  $dir . 'annotation.fasta';
  my $bed =  $dir . 'annotation.bed';
  #my $go =  $dir . 'annotation.go';

  open (FINAL,">",$final );
  open (BED,">",$bed );
  #open (GO, ">", $go);
  
  
  
  foreach my $gene (sort {$a <=> $b} keys %anno) {
    foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
      
      print FINAL ">", "c", $gene, "_g", $comp, " ", "Status:$anno{$gene}{$comp}{'complete'}", " ";
      print FINAL "RefID:$anno{$gene}{$comp}{'ncbiID'}", " ";     
      print FINAL "GeneFullName:", '"',$anno{$gene}{$comp}{'nameFull'}, '"', " ";
      print FINAL "CodingBlastHit:$anno{$gene}{$comp}{'query_start'}-$anno{$gene}{$comp}{'query_end'}", " ";
      print FINAL "CodingExonerateHit:$anno{$gene}{$comp}{'exonerate_start'}-$anno{$gene}{$comp}{'exonerate_end'}", " ";
      print FINAL "RefHit:$anno{$gene}{$comp}{'hit_start'}-$anno{$gene}{$comp}{'hit_end'}", " ";
      
      print FINAL "TranscriptLength:$anno{$gene}{$comp}{'length'}", " ";
      if ($anno{$gene}{$comp}{'exonerate_end'} eq "NA") {
	print FINAL "CodingLength:",$anno{$gene}{$comp}{'query_end'} - $anno{$gene}{$comp}{'query_start'} + 1,  " ";
      }
      else {
	print FINAL "CodingLength:",$anno{$gene}{$comp}{'exonerate_end'} - $anno{$gene}{$comp}{'exonerate_start'} + 1,  " ";
      } 

      print FINAL "Evalue:$anno{$gene}{$comp}{'evalue'}", " ";
      print FINAL "ID:$anno{$gene}{$comp}{'mismatch'}"," ";
      print FINAL "BitScore:$anno{$gene}{$comp}{'bit'}","\n";

      print FINAL $anno{$gene}{$comp}{'seq'}, "\n";
      
      if ($anno{$gene}{$comp}{'exonerate_end'} eq "NA") {
	print BED "c", $gene, "_g", $comp,  "\t", $anno{$gene}{$comp}{'query_start'}-1, "\t", $anno{$gene}{$comp}{'query_end'}, "\n";
      }
      else {	
	print BED "c", $gene, "_g", $comp,  "\t", $anno{$gene}{$comp}{'exonerate_start'}-1, "\t", $anno{$gene}{$comp}{'exonerate_end'}, "\n";
      }
      #print GO $gene, "_g", $comp, "\t", $anno{$gene}{$comp}{'go'}, "\n";
   }
  }
  
  close FINAL;
  close BED;
  #close GO;
}





sub annotateE {

  die(qq/
TransAnnotation annotateE [options] 

options:
-a    FILE      assembled fasta file by trinity
-o    DIR       full path to result folder (should be named including sampleName)
-t    INT       number of threads used in blastx search [10]
-e    FLOAT     maximal evalue for blastx hit [1e-10]
-m    INT       minimal percent mismatches to keep a hit [50] 
-r    FILE      Ensembl reference protein (you may used a combined protein reference)
-g    FILE      if "longest_protein.fasta" already generated, use it instead of -r (for refseq). 
-f    FILE      A file that contains all descriptions associated with reference gene 
                database (using Ensemble BioMart tool). Format see below. If multiple
                references are used then their corresponding biomart files should 
                also be merged to a single file    



Ensembl Gene ID,Associated Gene Name,Description
ENSG00000280820,LCN1P1,lipocalin 1 pseudogene 1 \[Source:HGNC Symbol;Acc:HGNC:23412\]
ENSG00000280549,PADI3,"peptidyl arginine deiminase, type III \[Source:HGNC Symbol;Acc:HGNC:18337\]"
ENSG00000281894,ZKSCAN7,zinc finger with KRAB and SCAN domains 7 \[Source:HGNC Symbol;Acc:HGNC:12955\]
ENSG00000281876,RP11-399E6.4,
ENSG00000280937,RP5-879K22.1,
ENSG00000281132,Y_RNA,Y RNA \[Source:RFAM;Acc:RF00019\]
          

!!Dependencies!!: 
NCBI BLAST+ (Blast database Homology Search): www.ncbi.nlm.nih.gov\/books\/NBK52640\/

\n\n/) unless (@ARGV);
  
  my %opts = (a=>undef, o=>undef,t=>10,e=>1e-10,m=>50,r=>undef, f=>undef,g=>undef);
  getopts('a:o:t:e:m:r:f:g:', \%opts);


  my $dir = dir($opts{o});
  mkdir $dir unless -e $dir;

  my $ass = $opts{a};
  my $np = $opts{t};
  my $evalue = $opts{e};
  my $assUnique = uniqueass ($ass) unless (-f $ass. ".unique");
  $assUnique = $ass. ".unique";
  ##define variables for filter
  my $mismat = $opts{m};
  my $name = $opts{f};
  my $long = $opts{g} if $opts{g} ;
  my $P = $opts{r} if $opts{r};
  
  #######choose the longest protein as reference for annotation##########
  
    
  my %prob;
  my $dbP = $dir . 'longest_protein.fasta'; 
  if ($P) {
    my $id;
    my $gene;
    open (REGION, "<", $P);
    while (<REGION>) {
      chomp (my $line = $_);
      if ($line =~ m/^>/) {
	chomp (my @l = split /\s+/, $line);
	next if $l[5] =~ m/pseudogene/;
	chomp (my @a = split /:/, $l[2]);
	$id = $1 if $l[0] =~ /^>(ENS\S+)/;
	#print $l[3], "\n" if $l[3] =~ /gene:(ENS\S+)\.\d+/;
	$gene = $1 if  $l[3] =~ /gene:(ENS\S+)\.\d+/;
      }
      else {
	$prob{$gene}{$id}{'seq'} .= $line;
	$prob{$gene}{$id}{'len'} += length($line);
      }
    }
    close REGION;
    
    open (OUT, ">", $dbP);
    
    foreach my $gene (sort {$a cmp $b} keys %prob) {
      foreach my $transcript (sort {$prob{$gene}{$b}{'len'} <=> $prob{$gene}{$a}{'len'}} keys %{$prob{$gene}}) {   
	print OUT ">$gene", "\n", $prob{$gene}{$transcript}{'seq'}, "\n"; 
	last;    
      }
    }
    close OUT;
  }
  if ($long) {
    system ("cp $long $dbP");
  }
     
  #################reading protein into an hash ################################
    my %protein;
    open(IN, "<", $dbP);
    my $ids;
    while (<IN>){ 
      chomp ($_);
      if ($_ =~ m/^>(ENS\S+)/){
	$ids = $1;
      }
      else {
	$protein{$ids}{'seq'} .= $_;
      }
    }
    close IN;
    ##############################################################################
    unless (-f $dbP . '.pin') {
      my $call = system("makeblastdb -in $dbP -dbtype prot");
    } 
    my $outfile1 = blastProteins($assUnique, $dbP, $np, $evalue, $dir, "0") unless (-f $dir . basename ($assUnique) . '.blast.out'); 
    $outfile1 = $dir . basename ($assUnique) . '.blast.out';
    my $seqref = readfasta ($assUnique);
    my $nameref = readbiomart ($name);
    annotateProt ($outfile1,$evalue, $mismat, $seqref, $nameref, $dir, \%protein); 
    
}

sub readbiomart {
  my ($name) = @_;
  my %nameref;
  open(NAME, "<", $name); 
   while(<NAME>){
    chomp(my $line = $_);	  
    if ($line =~ m/^(ENS[A-Z|0-9|_|-]+),/) {
      my $id = $1;
      
      my ($gene,$info);
      if ($line =~ /\s+\[Source/){
	if ($line =~ m/^ENS[A-Z|0-9|_|-]+,([0-9|A-Z|a-z|_|-]+),"*([\S+\s+^\[Source]+)\[Source/) {
	 
	  $gene = $1;
	  $info = $2;
	   
	}
	if ($line =~ m/^ENS[A-Z|0-9|_|-]+,,"*([\S+\s+^\[Source]+)\[Source/) {
	  $gene = 'NA';
	  $info = $1;

	}
      }
      else {
	if ($line =~ m/^ENS[A-Z|0-9|_|-]+,([0-9|A-Z|a-z|_|-]+),/)  {
	  $gene = $1;
	  $info = 'NA';
	}
	if ($line =~ m/^ENS[A-Z|0-9|_|-]+,,/) {
	  $gene = 'NA';
	  $info = 'NA';
	}
      }
	
      $nameref{$id} = {'gene' => $gene, 'info'=> $info, 'go'=>$line};
      
    }
  }
  close NAME;
 return (\%nameref);  
}


sub readfasta {
 my ($assembly) = @_;
 open(IN, "<", $assembly);
 my $id;
 my %seq;
 while(<IN>){
   chomp(my $line = $_);

   if ($line =~ m/>(\S+)/){
     $id = $1;
   }
   else {
     $seq{$id}{'seq'} .= $line;
     $seq{$id}{'length'} .= length ($line);
   }
 }
 close IN;
 return (\%seq);
}

sub exonerate {
  my ($dir, $anno, $protein) = @_;

  my %anno = %{$anno};
  my %protein = %{$protein};

  foreach my $gene (sort {$a <=> $b} keys %anno) {
    foreach my $comp (sort {$a <=> $b}  keys %{$anno{$gene}} ) {
      my $query = $dir . "query.fa";
      my $target = $dir . "target.fa";
      open(QUERY, ">", $query);
      open(TARGET, ">", $target);
      
      
      print QUERY ">", $gene, "_", $comp, "\n";
      print QUERY $anno{$gene}{$comp}{'seq'},"\n";
      
      print TARGET ">", $anno{$gene}{$comp}{"refgenefull"}, "\n";
      print TARGET $protein{$anno{$gene}{$comp}{"refgenefull"}}{'seq'},"\n";
      
      
      close(QUERY); close(TARGET);					
      my @call3 = `exonerate $target $query -m protein2genome --showalignment no --showcigar 0`;
      unlink($query); unlink($target);
      
      
      my @match;
      foreach (@call3) {
	chomp (my @line = split /\s+/, $_);
	if ($line[0] =~m /vulgar/) {
	  push @match, $line[6]+1;
	  push @match, $line[7];
	}
      } #foreach (@call3) {
      my $start = min (@match);
      my $end = max (@match);
      
      my @d = split(/\s+/,$call3[2]);
      if ($d[8]){
	if ($d[8] eq '+' || $d[8] eq '-') {
	  if ($d[8] eq '+') {
	    #this is in 5->3
	    
	    $anno{$gene}{$comp}{'exonerate_start'} = $start ;
	    $anno{$gene}{$comp}{'exonerate_end'} = $end ;
	    
	  }		
	  else {
	    #this is in 3->5;
	    print "Strange... blast and exonerate gave different orentation for ", $gene, "_", $comp, " when matching ", $anno{$gene}{$comp}{"refgenefull"}. "!\n";
	    print "Will follow blast!\n";
	    
	    my $gs = $anno{$gene}{$comp}{'length'} - $end + 2;
	    my $ge = $anno{$gene}{$comp}{'length'} - $start;
	    
	    $anno{$gene}{$comp}{'exonerate_start'} = $gs ;
	    $anno{$gene}{$comp}{'exonerate_end'} = $ge  ;
	
	  }
	} 
      }#if ($d[8]){
      #a blast match but no exonerate match?	
      if (!$d[8]) {
	print "Huh, this is odd. BLAST hit but not exonerate hit for ", $gene, "_", $comp,"?\n";
	print "Will follow blast!\n";
	$anno{$gene}{$comp}{'exonerate_start'} = "NA";
	$anno{$gene}{$comp}{'exonerate_end'} = "NA" ;
      }#(!$d[8])
    }
  }
  return (\%anno); 
}

sub blastProteins {
  my ($assembly, $dbP, $np,$evalue, $dir, $gi) = @_; 
  my $masterout = $dir . basename ($assembly) . '.blast.out';

  if ($gi eq "0") {
    my $call = system("blastx -db $dbP -query $assembly -num_threads $np -evalue $evalue -outfmt 6 -out $masterout -max_target_seqs 1"); 
  }
  else {
    my $call = system("blastx -db $dbP -query $assembly -num_threads $np -evalue $evalue -outfmt 6 -out $masterout -max_target_seqs 1 -gilist $gi");

  }
  return($masterout);	
}

sub annotateProt {
  my ($blast, $evalue, $mismat, $seqref, $nameref, $dir,$protein) = @_;
  
  my %anno;
  my %seq = %{$seqref};
  my %nameref = %{$nameref};
  my %protein = %{$protein};
  
  open (BLAST, "<", $blast);
  while (<BLAST>) {
    chomp (my @a = split /\s+/, $_);
    my $contigID = $a[0];
    my $gene;
    my $comp;
    if ($contigID =~ m /c(\S+)_g(\d+)_i\d+/) {
      $gene = $1;
      $comp = $2;
    }
    
    my $ensemblID = $a[1];
    my $ms = $a[2];
    next if $ms <= $mismat;
    next if $a[10] >= $evalue;
    my $queryStart = $a[6];
    my $queryEnd = $a[7];
    my $hitStart = $a[8];
    my $hitEnd = $a[9];
    my $eval = $a[10];
    
    if (!$anno{$gene}{$comp}) { 
      $anno{$gene}{$comp}{"refgenefull"} = $a[1];
      $anno{$gene}{$comp}{"mismatch"} = $a[2];
      $anno{$gene}{$comp}{"query_start"} = $a[6];
      $anno{$gene}{$comp}{"query_end"} = $a[7];
      $anno{$gene}{$comp}{"hit_start"} = $a[8];
      $anno{$gene}{$comp}{"hit_end"} = $a[9];
      $anno{$gene}{$comp}{"evalue"} = $a[10];
      $anno{$gene}{$comp}{"bit"} = $a[11];
      $anno{$gene}{$comp}{"seq"} = $seq{$contigID}{"seq"};
      $anno{$gene}{$comp}{"length"} = $seq{$contigID}{"length"};
      $anno{$gene}{$comp}{"nameShort"} = uc ($nameref{$a[1]}{'gene'}) if ($nameref{$a[1]}{'gene'});
      $anno{$gene}{$comp}{"nameShort"} = "NA" if (!$nameref{$a[1]}{'gene'}) ;
      $anno{$gene}{$comp}{"nameFull"} = $nameref{$a[1]}{'info'} if ($nameref{$a[1]}{'info'});
      $anno{$gene}{$comp}{"nameFull"} =  "NA" if (!$nameref{$a[1]}{'info'}) ;
      $anno{$gene}{$comp}{"go"} = $nameref{$a[1]}{'go'} if ($nameref{$a[1]}{'go'}) ;
      $anno{$gene}{$comp}{"go"} = "NA" if (!$nameref{$a[1]}{'go'}) ;
    }
  }
  close BLAST;

  my %ah;
  foreach my $gene (sort {$a <=> $b} keys %anno) {
    foreach my $comp (sort {$a <=> $b}  keys %{$anno{$gene}} ) {
      
      push @{$ah{$gene}{'comp'}}, $anno{$gene}{$comp}{'nameShort'};
      push @{$ah{$gene}{'gene'}}, $comp;
      
      if ($anno{$gene}{$comp}{'query_start'} >  $anno{$gene}{$comp}{'query_end'}) {
	$anno{$gene}{$comp}{'seq'} = reverse($anno{$gene}{$comp}{'seq'});
	$anno{$gene}{$comp}{'seq'} =~ tr/ATGC/TACG/;
	
	my $newstart = $anno{$gene}{$comp}{'length'} - $anno{$gene}{$comp}{'query_start'} + 1;
	my $newend = $anno{$gene}{$comp}{'length'} - $anno{$gene}{$comp}{'query_end'} + 1;
	
	$anno{$gene}{$comp}{'query_start'} = $newstart ;
	$anno{$gene}{$comp}{'query_end'} = $newend;

      }
    }  
  }

  my $newanno = exonerate ($dir, \%anno, \%protein);
  %anno = %{$newanno};



  foreach my $gene (sort {$a <=> $b} keys %anno) {
    
    if (scalar @{$ah{$gene}{'comp'}} == 1 ) {
      foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
	$anno{$gene}{$comp}{'complete'} = "all";
      }
    } #if (scalar @{$ah{$gene}{'comp'}} == 1 ) {
    
      if (scalar @{$ah{$gene}{'comp'}} > 1 ) {
	
	my %seen = ();
	foreach my $item (@{$ah{$gene}{'comp'}}) {
	  $seen{$item}++ ;
	}
	my @not_unique = grep { $seen{$_} > 1 } keys %seen ;
	
	my $d = 1;
	foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
	  
	  if (grep {$_ eq $anno{$gene}{$comp}{'nameShort'}} @not_unique) {
	    $anno{$gene}{$comp}{'complete'} = "part$d";
	    $d++;
	  }
	  else {
	    $anno{$gene}{$comp}{'complete'} = "all";
	  }
	} #foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_end'}} keys %{$anno{$gene}}) {
      } #if (scalar @{$ah{$gene}{'comp'}} > 1 ) {
  }#foreach my $gene (sort {$a cmp $b} keys %anno) {

  my $final =  $dir . 'annotation.fasta';
  my $bed =  $dir . 'annotation.bed';
  my $go =  $dir . 'annotation.go';

  open (FINAL,">",$final );
  open (BED,">",$bed );
  open (GO, ">", $go);
  
  
  
  foreach my $gene (sort {$a <=> $b} keys %anno) {
    foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
      
      print FINAL ">", "c", $gene, "_g", $comp, " ", "Status:$anno{$gene}{$comp}{'complete'}", " ";
      print FINAL "RefID:$anno{$gene}{$comp}{'refgenefull'}", " "; 
      print FINAL "GeneShortName:$anno{$gene}{$comp}{'nameShort'}", " ";
      print FINAL "GeneFullName:", '"',$anno{$gene}{$comp}{'nameFull'}, '"', " ";
      print FINAL "CodingBlastHit:$anno{$gene}{$comp}{'query_start'}-$anno{$gene}{$comp}{'query_end'}", " ";
      print FINAL "CodingExonerateHit:$anno{$gene}{$comp}{'exonerate_start'}-$anno{$gene}{$comp}{'exonerate_end'}", " ";
      print FINAL "RefHit:$anno{$gene}{$comp}{'hit_start'}-$anno{$gene}{$comp}{'hit_end'}", " ";

      print FINAL "TranscriptLength:$anno{$gene}{$comp}{'length'}", " ";
      if ($anno{$gene}{$comp}{'exonerate_end'} eq "NA") {
	print FINAL "CodingLength:",$anno{$gene}{$comp}{'query_end'} - $anno{$gene}{$comp}{'query_start'} + 1,  " ";
      }
      else {
	print FINAL "CodingLength:",$anno{$gene}{$comp}{'exonerate_end'} - $anno{$gene}{$comp}{'exonerate_start'} + 1,  " ";
      } 
      
      
      print FINAL "Evalue:$anno{$gene}{$comp}{'evalue'}", " ";
      print FINAL "BitScore:$anno{$gene}{$comp}{'bit'}", " ";
      print FINAL "ID:$anno{$gene}{$comp}{'mismatch'}","\n";
      
      print FINAL $anno{$gene}{$comp}{'seq'}, "\n";
      
      if ($anno{$gene}{$comp}{'exonerate_end'} eq "NA") {
	print BED "c", $gene, "_g", $comp,  "\t", $anno{$gene}{$comp}{'query_start'}-1, "\t", $anno{$gene}{$comp}{'query_end'}, "\n";
      }
      else {	
	print BED "c", $gene, "_g", $comp,  "\t", $anno{$gene}{$comp}{'exonerate_start'}-1, "\t", $anno{$gene}{$comp}{'exonerate_end'}, "\n";
      }
      
      print GO "c", $gene, "_g", $comp, "\t", $anno{$gene}{$comp}{'go'}, "\n";
    }
  }
  
  close FINAL;
  close BED;
  close GO;
}



sub annotateU {
  die(qq/
TransAnnotation annotateU [options] 

options:
-a    FILE      assembled fasta file by trinity
-o    DIR       full path to result folder (should be named including sampleName)
-t    INT       number of threads used in blastx search [10]
-e    FLOAT     maximal evalue for blastx hit [1e-10]
-m    INT       minimal percent mismatches to keep a hit [50] 
-g    FILE      full path to uniprot_sprot.trinotate.pep
-q    FILE      full path to Trinotate.sqlite
-P    FILE      full path to Pfam-A.hmm
-f    INT       taxonomic filter: only keep annotations belonging to on the following [1]
                1: Vertebrata
                2: Mammalia
                3: Testudines + Archosauria group
                4: Amphibia
                5: Actinopterygii
-p   FILE       Additional UniProtKB\/Swiss-Prot and UniProtKB\/TrEMBL reference to 
                be added to the existing reference [null]
                

!!Dependencies!!: 

Trinity: (includes TransDecoder and support for expression and DE analysis using RSEM and Bioconductor): trinityrnaseq.github.io
Trinotate: trinotate.github.io 
sqlite (required for database integration): www.sqlite.org
NCBI BLAST+ (Blast database Homology Search): www.ncbi.nlm.nih.gov\/books\/NBK52640\/
HMMER\/PFAM Protein Domain Identification: hmmer.janelia.org\/download.html

                
\n\n/) unless (@ARGV);
  
  my %opts = (a=>undef, o=>undef,t=>10,e=>1e-10,m=>50,f=>1,p=>undef,g=>undef,q=>undef,P=>undef);
  getopts('a:o:t:e:m:f:p:g:q:P:', \%opts);
  
  ##define variables for annotatecore
  my $outdir = dir ($opts{o});
  mkdir $outdir unless -e $outdir; 
  my $ass = $opts{a};
  my $th = $opts{t};
  my $evalue = $opts{e};
  
  ##define variables for filter
  my $mismat = $opts{m};
  my $taxon;
  $taxon = "Vertebrata" if $opts{f} == 1;
  $taxon = "Mammalia" if $opts{f} == 2;
  $taxon = "Testudines + Archosauria group" if  $opts{f} == 3;
  $taxon = "Amphibia" if $opts{f} == 4;
  $taxon = "Actinopterygii" if $opts{f} == 5;
  
 # my $ref = dirname (abs_path($0)) . "/refs/uniprot_sprot.trinotate.pep";
  my $ref =$opts{g};
  my $refsq = $opts{q};
  my $pf = $opts{P};
  my %protein;
  open(IN, "<", $ref);
  my $ids;
  while (<IN>){ 
    chomp ($_);
    if ($_ =~ m/^>(\S+)/){
      $ids = $1;
    }
    else {
      $protein{$ids}{'seq'} .= $_;
    }
  }
  close IN;
  
  unless (-f $outdir . "trinotate_annotation_report.txt") {
    if ($opts{p}){
       annotatecore ($outdir, $ass, $th, $evalue, $opts{p},$ref,$refsq,$pf);
    }
    else {
       annotatecore ($outdir, $ass, $th, $evalue, "0",$ref,$refsq,$pf);
    }
  }
      
  my $report = $outdir . "trinotate_annotation_report.txt"  or die ("can not find annotation report!\n");
  my $unique = $ass . ".unique" or die ("can not find assemblies containing unique transcripts!\n");
  my $final =  filter ($outdir,$mismat, $taxon, $report, $unique, \%protein,$evalue);  
}



sub filter {
  my ($outdir,$mismat, $taxon, $report, $unique, $protein, $evalue) = @_;
  
  my %assembly;
  my %protein = %{$protein};
  
  open (ASS, "<", $unique);
  my $geneid;
  my $compid;
  while (<ASS>) {
    chomp (my $line = $_);
    if ($line =~ m/^>c(\d+)_g(\d+)_i\d+/) {
      $geneid = $1;
      $compid = $2;
    }
    else {
      $assembly{$geneid}{$compid}{'seq'} .= $line;
      $assembly{$geneid}{$compid}{'length'} += length ($line);
    }
  }
  close ASS;
  
  
  my $final = $outdir . "annotation.fasta";
  my $bed = $outdir . "annotation.bed";
  my $go = $outdir . "annotation.go";

  my %anno;
  open (IN, "<", $report);
  while (<IN>) {
    chomp (my $line = $_);
    chomp (my @a = split /\s+/, $line);
    next if $line !~ /$taxon/;
    next if $a[2] eq ".";
    
    chomp (my @blastx = split /\^/, $a[2]);
    my $ms;
    if ($blastx[3] =~ m /(\S+)%/){
      $ms = $1
    }
    next if $ms <= $mismat;

    my $e;
    if ($blastx[4] =~ m /E:(\S+)/) {
      $e = $1;
    }
    next if $e >= $evalue;

      
    my $contig = $a[0];
    my $gene;
    my $comp;
    if ($contig =~ /c(\S+)_g(\S+)/) {
      $gene = $1;
      $comp = $2;
    }
    
    
    $anno{$gene}{$comp}{'refgenefull'} = $blastx[0];
    
    if ($blastx[0] =~ /(\S+)_(\S+)/) {
      $anno{$gene}{$comp}{'refgenename'} = $1;
      $anno{$gene}{$comp}{'refgenespe'} = $2;	
    }
    if ($blastx[0] !~ /(\S+)_(\S+)/) {
      exit;
    }
    
    if ($blastx[2] =~ m /Q:(\d+)-(\d+),H:(\d+)-(\d+)/) {
      $anno{$gene}{$comp}{'query_start'} = $1;
      $anno{$gene}{$comp}{'query_end'} = $2;
      $anno{$gene}{$comp}{'hit_start'} = $3;
      $anno{$gene}{$comp}{'hit_end'} = $4;
    }
    if ($blastx[2] !~ m /Q:(\d+)-(\d+),H:(\d+)-(\d+)/) {
      print $blastx[2], "\n";
      exit;
    }
    
    if ($blastx[4] =~ m /E:(\S+)/){
      $anno{$gene}{$comp}{'evalue'} = $1;
    }
    if ($blastx[4] !~ m /E:(\S+)/){
      print $blastx[4], "\n";
      exit;
    }
    
    if ($line =~ m /RecName: Full=([^;]+);/){
      $anno{$gene}{$comp}{'fullname'} = $1;
    }
    if ($line !~ m /RecName: Full=([^;]+);/){
      print $line, "\n";
      exit;
    }
    
    if ($line =~ m /\s+(GO[^\.]+)\./){
	$anno{$gene}{$comp}{'go'}= $1;
      }
    if ($line !~ m /\s+(GO[^\.]+)\./){
      $anno{$gene}{$comp}{'go'} = "NA";
    }
    
    if ($blastx[3] =~ m /(\S+)%/){
      $anno{$gene}{$comp}{'mismatch'} = $1;
      
    }
    if ($blastx[3] !~ m /(\S+)%/){
      print $blastx[3], "\n";
      exit;
    }  
  }
  close IN;
  
  my %ah;
    foreach my $gene (sort {$a <=> $b} keys %anno) {
      foreach my $comp (sort {$a <=> $b}  keys %{$anno{$gene}} ) {
	
	$anno{$gene}{$comp}{'seq'} = $assembly{$gene}{$comp}{'seq'};
	$anno{$gene}{$comp}{'length'} = $assembly{$gene}{$comp}{'length'};
	
	push @{$ah{$gene}{'comp'}}, $anno{$gene}{$comp}{'refgenename'};
	push @{$ah{$gene}{'gene'}}, $comp;
	
	if ($anno{$gene}{$comp}{'query_start'} >  $anno{$gene}{$comp}{'query_end'}) {
	  $anno{$gene}{$comp}{'seq'} = reverse($anno{$gene}{$comp}{'seq'});
	  $anno{$gene}{$comp}{'seq'} =~ tr/ATGC/TACG/;
	  
	  my $newstart = $anno{$gene}{$comp}{'length'} - $anno{$gene}{$comp}{'query_start'} + 1;
	  my $newend = $anno{$gene}{$comp}{'length'} - $anno{$gene}{$comp}{'query_end'} + 1;
	  
	  $anno{$gene}{$comp}{'query_start'} = $newstart ;
	  $anno{$gene}{$comp}{'query_end'} = $newend;
	  	  
	}
      }  
    }

  my $newanno = exonerate ($outdir, \%anno, \%protein);
  %anno = %{$newanno};
  
  undef %assembly;
  
  foreach my $gene (sort {$a <=> $b} keys %anno) {
    
    if (scalar @{$ah{$gene}{'comp'}} == 1 ) {
      foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
	$anno{$gene}{$comp}{'complete'} = "all";
      }
    } #if (scalar @{$ah{$gene}{'comp'}} == 1 ) {
    
      if (scalar @{$ah{$gene}{'comp'}} > 1 ) {
	
	my %seen = ();
	foreach my $item (@{$ah{$gene}{'comp'}}) {
	  $seen{$item}++ ;
	}
	my @not_unique = grep { $seen{$_} > 1 } keys %seen ;
	
	my $d = 1;
	foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
	  
	  if (grep {$_ eq $anno{$gene}{$comp}{'refgenename'}} @not_unique) {
	    $anno{$gene}{$comp}{'complete'} = "part$d";
	    $d++;
	  }
	  else {
	    $anno{$gene}{$comp}{'complete'} = "all";
	  }
	} #foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_end'}} keys %{$anno{$gene}}) {
      } #if (scalar @{$ah{$gene}{'comp'}} > 1 ) {
  }#foreach my $gene (sort {$a cmp $b} keys %anno) {


  open (FINAL,">",$final );
  open (BED,">",$bed );
  open (GO,">",$go );
  
  foreach my $gene (sort {$a <=> $b} keys %anno) {
    foreach my $comp (sort {$anno{$gene}{$a}{'hit_start'} <=> $anno{$gene}{$b}{'hit_start'}} keys %{$anno{$gene}}) {
      
      print FINAL ">", "c", $gene, "_g", $comp, " ", "Status:$anno{$gene}{$comp}{'complete'}", " ";
      print FINAL "GeneShortName:$anno{$gene}{$comp}{'refgenename'}", " ";
      print FINAL "GeneFullName:", '"',$anno{$gene}{$comp}{'fullname'}, '"', " ";
      print FINAL "RefSpecies:$anno{$gene}{$comp}{'refgenespe'}", " ";
      print FINAL "CodingBlastHit:$anno{$gene}{$comp}{'query_start'}-$anno{$gene}{$comp}{'query_end'}", " ";
      print FINAL "CodingExonerateHit:$anno{$gene}{$comp}{'exonerate_start'}-$anno{$gene}{$comp}{'exonerate_end'}", " ";
      
      print FINAL "RefHit:$anno{$gene}{$comp}{'hit_start'}-$anno{$gene}{$comp}{'hit_end'}", " ";

      print FINAL "TranscriptLength:$anno{$gene}{$comp}{'length'}", " ";
      if ($anno{$gene}{$comp}{'exonerate_end'} eq "NA") {
	print FINAL "CodingLength:",$anno{$gene}{$comp}{'query_end'} - $anno{$gene}{$comp}{'query_start'} + 1,  " ";
      }
      else {
	print FINAL "CodingLength:",$anno{$gene}{$comp}{'exonerate_end'} - $anno{$gene}{$comp}{'exonerate_start'} + 1,  " ";
      } 

      
      print FINAL "Evalue:$anno{$gene}{$comp}{'evalue'}", " ";
      print FINAL "ID:$anno{$gene}{$comp}{'mismatch'}","\n";
      
      print FINAL $anno{$gene}{$comp}{'seq'}, "\n";
      
      if ($anno{$gene}{$comp}{'exonerate_end'} eq "NA") {
	print BED "c", $gene, "_g", $comp,  "\t", $anno{$gene}{$comp}{'query_start'}-1, "\t", $anno{$gene}{$comp}{'query_end'}, "\n";
      }
      else {	
	print BED "c",$gene, "_g", $comp,  "\t", $anno{$gene}{$comp}{'exonerate_start'}-1, "\t", $anno{$gene}{$comp}{'exonerate_end'}, "\n";
      }
      
      print GO  "c", $gene, "_g", $comp, "\t", $anno{$gene}{$comp}{'go'}, "\n";
      
    }
  }
  
  close FINAL;
  close BED;
  close GO;
  
}


sub uniqueass {
  my ($ass) = @_;

  my $assUnique = $ass . ".unique";
   
  #system ("TransDecoder.LongOrfs -t $ass -m 30") ;
  #my $transdir = $ass . ".transdecoder_dir/";
  #my $ass2 = $transdir. "longest_orfs.cds";
  #open (IN, "<", $ass2);


  open (IN, "<", $ass);
  open (OUT, ">", $assUnique);
  
  my %trans;
  
  my %genecount;
  my $comp;
  my $ad;
  my $gene;
  my $len;
  my $iso;
  my $dd =1;
  
  my $dcount = 1;
  while (<IN>) {
    my $l = $_;
    chomp (my @l = split/\s+/, $_);
    if ($l =~ m/gene=isogroup(\d+)/) {
      $comp = $1;
      $gene = $comp;
      $iso = $dcount;
      $dcount++;
      $len = $1 if $l[1] =~ m/length=(\d+)/;
    }
    elsif ($l[0] =~ m/^>c(\d+)_g(\d+)_i(\d+)/) { #c98_g1_i1
      $comp = $1;
      $gene = $2;
      $iso = $3;
      $len = $1 if $l[1] =~ m/len=(\d+)/;
    }  
    elsif ($l[0] =~ m/^>TRINITY_DN(\d+)_c(\d+)_g(\d+)_i(\d+)/) {

      $comp = $1 . $2;
      $gene = $3;
      $iso = $4;     
      $len = $1 if $l[1] =~ m/len=(\d+)/;
      
    }
    else {
      $trans{$comp}{$gene}{$iso}{"seq"} .= $l[0];     
      $trans{$comp}{$gene}{$iso}{"length"} = $len;     
    }    
  }
  close IN;

  
  my %ah;
  my %ind;
  foreach my $comp (sort {$a <=> $b} keys %trans) {
    foreach my $gene (sort {$a <=> $b} keys %{$trans{$comp}}) { 
      foreach my $iso (sort {$a <=> $b} keys %{$trans{$comp}{$gene}}) {
	push @{$ah{$comp}{$gene}}, $trans{$comp}{$gene}{$iso}{"length"};
	push @{$ind{$comp}{$gene}}, $iso;
      }
      if (scalar @{$ah{$comp}{$gene}} > 1 ) {
	my $index = 0;
	$ah{$comp}{$gene}[$index] > $ah{$comp}{$gene}[$_] or $index = $_ for 1 .. $#{$ah{$comp}{$gene}};
	print OUT  ">c", $comp, "_g", $gene, "_i", $ind{$comp}{$gene}[$index], "\n";
	#print  ">c", $comp, "_g", $gene, "_i", $ind{$comp}{$gene}[$index], "\n";
	print OUT   $trans{$comp}{$gene}{$ind{$comp}{$gene}[$index]}{'seq'}, "\n";
	#print   $trans{$comp}{$gene}{$ind{$comp}{$gene}[$index]}{'seq'}, "\n";
      }
      else {
	print OUT  ">c", $comp, "_g", $gene, "_i", $ind{$comp}{$gene}[0],"\n";
	print OUT  $trans{$comp}{$gene}{$ind{$comp}{$gene}[0]}{"seq"}, "\n";	
      }
    }    
  } 
  close OUT;

  my $assUnique_cdhit = $assUnique. ".cdhit";
  system ("cd-hit-est -i  $assUnique -M 0 -r 1 -T 5 -l 100 -o $assUnique_cdhit ");
  system ("mv $assUnique_cdhit $assUnique");
  return ($assUnique);
  
}
   
sub annotatecore {
  my ($outdir, $ass, $th, $evalue, $addref,$ref,$sqlbase,$Pfam) = @_; 
  ##pick the longest isofrom from each gene
  my $assUnique = uniqueass ($ass) unless (-f $ass. ".unique");
  $assUnique = $ass . ".unique";
  #my $ref = dirname (abs_path($0)) . "/refs/uniprot_sprot.trinotate.pep";
  #my $sqlbase = dirname(abs_path($0)) . "/refs/Trinotate.sqlite";
  
  my @trinity_path = `which Trinity`;
  my $trinitypath = dirname ("@trinity_path");
  my $mapper = $trinitypath . "/util/support_scripts/get_Trinity_gene_to_trans_map.pl";
  system ("makeblastdb -in $ref -dbtype prot") unless (-f $ref . '.pin');
  
  system ("TransDecoder.LongOrfs -t $assUnique");
  system ("TransDecoder.Predict  -t $assUnique  --retain_long_orfs 90");
  
  my $pep = $assUnique . ".transdecoder.pep";
  my $blastxout = $outdir . "blastx.outfmt6";
  my $blastpout = $outdir . "blastp.outfmt6";
  
  # search Trinity transcripts
  system ("blastx -query $assUnique -db $ref -num_threads $th -max_target_seqs 1 -outfmt 6 > $blastxout");
  # search Transdecoder-predicted proteins
  system ("blastp -query $pep -db $ref -num_threads $th -max_target_seqs 1 -outfmt 6 > $blastpout");
  
  my $PFAM = $outdir . "TrinotatePFAM.out";
  my $PFAMlog = $outdir . "pfam.log";
  #my $Pfam = dirname (abs_path($0)) . "/refs/Pfam-A.hmm";
  
  system ("hmmscan --cpu $th --domtblout $PFAM $Pfam $pep > $PFAMlog");
  
  my $mapout = $outdir . "Trinity.fasta.gene_trans_map";
  system ("$mapper $assUnique>  $mapout");
  
  system ("Trinotate $sqlbase init --gene_trans_map $mapout --transcript_fasta $assUnique --transdecoder_pep $pep");
  system ("Trinotate $sqlbase LOAD_swissprot_blastp $blastpout");
  system ("Trinotate $sqlbase LOAD_swissprot_blastx $blastxout");
  system ("Trinotate $sqlbase LOAD_pfam $PFAM");
  
  my $report = $outdir . "trinotate_annotation_report.txt";
  system ("Trinotate $sqlbase report -E $evalue > $report");
  

}


sub dir {
  my ($dir) = @_;
  my $out;
  if ($dir =~ m/\/$/ ){
    $out = $dir; 
  }
  else {
    $out = $dir . "/";
  }
  return ($out);
}

sub removeOverlap {
  my ($array, $contigs, $a, $maxOverlap) = @_;
  my %contigs = %{$contigs};
  my %a = %{$a};
  my @overlap;
  my $c = 0;
  
  for (my $i = 0; $i < scalar(@$array); $i++) {
    #length of the assembled contig
    my $leni = length ($contigs {$array->[$i]->[0]}) ;   
      #print min($array->[$i]->[8],$array->[$i]->[9]), "\t", max($array->[$i]->[8],$array->[$i]->[9]),"hoho\n" if $array->[$i]->[0] eq "contig36" ;
    my %bp;
    for (my $n = min($array->[$i]->[8],$array->[$i]->[9]); $n <= max($array->[$i]->[8],$array->[$i]->[9]); $n++) { 
      $bp{$n}++;
    }

    for (my $j = $i+1; $j < scalar(@$array); $j++) { 
      my $lenj = length ($contigs {$array->[$j]->[0]}) ;

      my $overlap = 0;
     # print min($array->[$i]->[8],$array->[$i]->[9]), "\t", max($array->[$i]->[8],$array->[$i]->[9]), "\t", min($array->[$j]->[8],$array->[$j]->[9]), "\t", max($array->[$j]->[8],$array->[$j]->[9]),"haha\n" if $array->[$i]->[0] eq "contig36";

      
      for (my $m = min($array->[$j]->[8],$array->[$j]->[9]); $m <= max($array->[$j]->[8],$array->[$j]->[9]); $m++) {
	  $overlap++ if $bp{$m};
	}

      #print min($array->[$j]->[8],$array->[$j]->[9]), "\t", max($array->[$j]->[8],$array->[$j]->[9]),"\n" if $array->[$j]->[0] eq "contig44" ;
      #print $overlap, "\n"  if $array->[$i]->[0] eq "contig36";
      #print $overlap, "\n"  if $array->[$i]->[0] eq "contig36" && $array->[$j]->[0] eq "contig44";
      
      $overlap = $overlap / min(abs($array->[$i]->[8] - $array->[$i]->[9]),abs($array->[$j]->[8] - $array->[$j]->[9]));
      #print $array->[$i]->[8], "\t", $array->[$i]->[9],"\t", $array->[$j]->[8], "\t", $array->[$j]->[9],"\n"  if $array->[$i]->[0] eq "contig36" && $array->[$j]->[0] eq "contig44";
	
      if ($overlap > $maxOverlap) {
	if  ($array->[$i] && $array->[$j]) {
	  #print $array->[$i]->[0],"\t", $array->[$j]->[0],"\n" if $array->[$i]->[0] eq "contig36" && $array->[$j]->[0] eq "contig44";
	  #print $array->[$i]->[8], "\t", $array->[$i]->[9],"\t", $array->[$j]->[8], "\t", $array->[$j]->[9],"\n"  if $array->[$i]->[0] eq "contig36" && $array->[$j]->[0] eq "contig44";
         
	  #print $overlap, "\n";
	  if ( ($array->[$i]->[0]) eq ($array->[$j]->[0]) ) {
	    #print $array->[$i]->[0] , "\t", $array->[$j]->[0], "\n";
	    $overlap[$c]-> [0] = abs($array->[$i]->[9] - $array->[$i]->[8]);
	    $overlap[$c]-> [1] = $array->[$i]->[6];
	    $overlap[$c]-> [2] = $array->[$i]->[7];
	    $overlap[$c]-> [3] = $array->[$i]->[0];
	    $c++;
	    $overlap[$c]-> [0] = abs($array->[$j]->[9] - $array->[$j]->[8]);
	    $overlap[$c]-> [1] = $array->[$j]->[6];
	    $overlap[$c]-> [2] = $array->[$j]->[7];
	    $overlap[$c]-> [3] = $array->[$j]->[0];
	    $c++;
	    
	    if ( abs($array->[$i]->[8] - $array->[$i]->[9]) > abs($array->[$j]->[8] - $array->[$j]->[9]) ) {
	      splice(@$array,$j,1);
	      
	    }
	    elsif ( abs($array->[$i]->[8] - $array->[$i]->[9]) <= abs($array->[$j]->[8] - $array->[$j]->[9]) ) {
	      splice(@$array,$i,1);	     
	    }
	    else {
	      next;
	    }
	  }#if ( ($array->[$i]->[0]) eq ($array->[$j]->[0]) ) {
	  
	  else  {
	    if ( abs($array->[$i]->[8] - $array->[$i]->[9]) - abs($array->[$j]->[8] - $array->[$j]->[9]) > 20 ) { 
	      #print $array->[$j]->[0],"\t", $array->[$i]->[0], "\n\n";
	      #print $i, "\n";
	      splice(@$array,$j,1);				
	    }
	    elsif ( abs($array->[$j]->[8] - $array->[$j]->[9]) - abs($array->[$i]->[8] - $array->[$i]->[9]) > 20 ) {
	      #print $array->[$i]->[0],"\t", $array->[$j]->[0],"\n";
	      splice(@$array,$i,1);			
	    }
	    
	    elsif ( abs (abs($array->[$j]->[8] - $array->[$j]->[9]) - abs($array->[$i]->[8] - $array->[$i]->[9])) <= 20 ) {
	      #print $array->[$j]->[0],"\t", $array->[$i]->[0],"\n"; 
	      if ( $lenj > $leni ) {
		my $name = $array->[$i]->[0];
		#print $name, "!\n";
		for (my $m = 0; $m < scalar(@$array); $m ++) {
		  splice(@$array,$m,1) if $array->[$m]->[0] eq $name;
		  
		}
	      }
	      
	      elsif ( $lenj <= $leni ) {
		my $name = $array->[$j]->[0];
		#print $name, "!\n";
		for (my $m = 0; $m < scalar(@$array); $m ++) {
		  
		  splice(@$array,$m,1) if $array->[$m]->[0] eq $name;
		  
		}
	      }	
	    }
	  } #else
	} #if  ($array->[$i] && $array->[$j])
	removeOverlap($array, \%contigs, \%a,$maxOverlap);
	last;
      }#if ($overlap > $maxOverlap) {
    }#for (my $j = $i+1; $j < scalar(@$array); $j++) { 
  }
  
  return($array, \%a, \@overlap);	
}
